# core/detail_information_getter.py
from __future__ import annotations

"""
DetailInformationGetter
- ka10095 : /api/dostk/stkinfo    (상세/현재가/체결강도 등)
- ka10080 : /api/dostk/chart      (분봉 차트)
- ka10081 : /api/dostk/chart      (일봉 차트)

Env
- HTTP_API_BASE  (ex: https://api.kiwoom.com)
- ACCESS_TOKEN   (Bearer 없이 토큰 원문)
- HTTP_TIMEOUT   (초, 기본 7.0)

Usage(동기):
    cfg = HTTPConfig()
    getter = DetailInformationGetter(cfg)
    d = getter.fetch_stock_info("005930")
    df5 = getter.minute_df("005930", minutes=5, need=350)
    dfd = getter.daily_df("005930", need=400)
    macd, sig, hist = getter.macd_series(dfd)

Usage(비동기):
    macd, ... = await getter.a_macd_series(await getter.a_daily_df("005930"))
"""

import os
import re
import asyncio
import logging
from dataclasses import dataclass
from time import perf_counter
from typing import Any, Dict, List, Optional, Callable, Union
import datetime as dt

import requests
import pandas as pd


# ──────────────────────────────────────────────────────────────
# 로깅
# ──────────────────────────────────────────────────────────────
logger = logging.getLogger(__name__)


# ──────────────────────────────────────────────────────────────
# 설정
# ──────────────────────────────────────────────────────────────
@dataclass
class HTTPConfig:
    base_url: str = os.getenv("HTTP_API_BASE", "https://api.kiwoom.com").rstrip("/")
    token: Optional[str] = os.getenv("ACCESS_TOKEN") or None
    token_provider: Optional[Callable[[], str]] = None
    # API IDs
    stkinfo_api_id: str = os.getenv("HTTP_STKINFO_API_ID", "ka10095")   # 관심종목/상세
    chart_api_id:   str = os.getenv("HTTP_CHART_API_ID", "ka10080")     # 분봉차트
    daily_api_id:   str = os.getenv("HTTP_DAILY_API_ID", "ka10081")     # 일봉차트
    timeout: float = float(os.getenv("HTTP_TIMEOUT", "7.0"))


# ──────────────────────────────────────────────────────────────
# 유틸
# ──────────────────────────────────────────────────────────────
_CODE6_RE = re.compile(r"(\d{6})")


def _normalize_code6(code: str) -> str:
    s = str(code or "").strip()
    m = _CODE6_RE.search(s)
    if m:
        return m.group(1)
    digits = re.sub(r"\D", "", s)
    if len(digits) >= 6:
        return digits[-6:]
    return s[-6:].zfill(6)


def _to_stk_cd(codes: Union[str, List[str]], exchange_prefix: str = "KRX") -> str:
    if isinstance(codes, str):
        codes = [c.strip() for c in codes.split("|") if c.strip()]
    out: List[str] = []
    for c in codes:
        out.append(c if ":" in c else f"{exchange_prefix}:{str(c).strip().zfill(6)}")
    return "|".join(out)


def _extract_code6_from_stkcd(stk_cd: Optional[str]) -> str:
    if not stk_cd:
        return ""
    s = str(stk_cd)
    if ":" in s:
        s = s.split(":", 1)[1]
    if "_" in s:
        s = s.split("_", 1)[0]
    m = _CODE6_RE.search(s)
    return m.group(1) if m else s[-6:].zfill(6)


def _code6_from_record(rec: Dict[str, Any], default: str = "") -> str:
    for key in ("stk_cd", "stkcd", "isu_cd", "code", "stock_code", "ticker", "sym"):
        val = rec.get(key)
        rc6 = _extract_code6_from_stkcd(val)
        if rc6:
            return rc6
    return default


def _to_float(x: Any, default: float = 0.0) -> float:
    try:
        return float(str(x).replace(",", ""))
    except Exception:
        return default


# ──────────────────────────────────────────────────────────────
# 본체
# ──────────────────────────────────────────────────────────────
class DetailInformationGetter:
    def __init__(self, cfg: HTTPConfig):
        self.cfg = cfg
        logger.info("[DetailInformationGetter] base_url=%s", self.cfg.base_url)

    # ------------------ 내부: 헤더 ------------------
    def _token(self) -> str:
        return (self.cfg.token_provider() or "") if self.cfg.token_provider else (self.cfg.token or "")

    def _headers(self, api_id: str, cont_yn: Optional[str] = None, next_key: Optional[str] = None) -> Dict[str, str]:
        h = {
            "authorization": f"Bearer {self._token()}",
            "api-id": api_id,
            "content-type": "application/json;charset=UTF-8",
            "accept": "application/json",
        }
        if cont_yn:
            h["cont-yn"] = cont_yn
        if next_key:
            h["next-key"] = next_key
        return h

    # ==========================================================
    # 1) ka10095: 상세/현재가(간단 정규화)
    # ==========================================================
    def fetch_stock_info(self, code: str, *, exchange_prefix: str = "KRX") -> Dict[str, Any]:
        """
        /api/dostk/stkinfo (ka10095)
        return: {'stock_code','stock_name','cur_prc','flu_rt','open_pric',...}
        """
        url = f"{self.cfg.base_url}/api/dostk/stkinfo"
        body = {"stk_cd": _to_stk_cd(code, exchange_prefix)}
        code6 = _normalize_code6(code)

        cont_yn, next_key = None, None
        collected: List[Dict[str, Any]] = []

        logger.info("[ka10095] URL=%s stk_cd=%s", url, body["stk_cd"])
        while True:
            headers = self._headers(self.cfg.stkinfo_api_id, "Y" if next_key else None, next_key)
            t0 = perf_counter()
            resp = requests.post(url, headers=headers, json=body, timeout=self.cfg.timeout)
            elapsed = (perf_counter() - t0) * 1000.0
            resp.raise_for_status()

            cont_yn = resp.headers.get("cont-yn", "N")
            next_key = resp.headers.get("next-key")
            js = resp.json()

            data = (
                js.get("atn_stk_infr")
                or js.get("body", {}).get("atn_stk_infr")
                or js.get("data", {}).get("atn_stk_infr")
                or []
            )
            if isinstance(data, list):
                # 단일 요청인데 코드 빠져오면 보강
                if "|" not in body["stk_cd"] and data and not any(item.get("stk_cd") for item in data):
                    for item in data:
                        item["stk_cd"] = f"{exchange_prefix}:{code6}"
                collected.extend(data)

            logger.info("[ka10095] page status=%s (%.1fms) cont-yn=%s next-key=%s recv=%d total=%d",
                        resp.status_code, elapsed, cont_yn, next_key, len(data) if isinstance(data, list) else 0, len(collected))
            if cont_yn != "Y" or not next_key:
                break

        chosen = None
        for rec in collected:
            if _code6_from_record(rec) == code6:
                chosen = rec
                break
        if not chosen and collected:
            chosen = collected[0]

        return self._normalize_detail_record(chosen) if chosen else {"stock_code": code6}

    @staticmethod
    def _normalize_detail_record(rec: Dict[str, Any]) -> Dict[str, Any]:
        norm = {
            "stock_code": _code6_from_record(rec),
            "stock_name": rec.get("stk_nm"),
            "cur_prc": rec.get("cur_prc"),
            "flu_rt": rec.get("flu_rt"),
            "open_pric": rec.get("open_pric"),
            "high_pric": rec.get("high_pric"),
            "low_pric": rec.get("low_pric"),
            "now_trde_qty": rec.get("trde_qty"),
            "cntr_str": rec.get("cntr_str"),
            "open_pric_pre": rec.get("pred_pre"),
            # 참고 값
            "base_pric": rec.get("base_pric"),
            "pred_pre": rec.get("pred_pre"),
            "pred_pre_sig": rec.get("pred_pre_sig"),
            "sel_bid": rec.get("sel_bid"),
            "buy_bid": rec.get("buy_bid"),
        }
        return {k: v for k, v in norm.items() if v not in (None, "", [])}

    # ==========================================================
    # 2) ka10080: 분봉 차트 rows → DataFrame
    # ==========================================================
    def fetch_minute_rows(
        self,
        code: str,
        *,
        minutes: int | str = 5,
        need: int = 350,
        upd_stkpc_tp: str = "1",
        exchange_prefix: str = "KRX",
    ) -> List[Dict[str, Any]]:
        """
        /api/dostk/chart (ka10080) 분봉
        반환: [{'dt':'YYYYMMDD','cntr_tm':'HHMMSS','cur_prc':'...','trde_qty':'...'}, ...] 오래된→최신
        """
        url = f"{self.cfg.base_url}/api/dostk/chart"
        m = str(minutes)
        body = {
            "stk_cd": _to_stk_cd(code, exchange_prefix),
            "tic_scope": m,             # 문서: 틱범위(분)
            "upd_stkpc_tp": str(upd_stkpc_tp),
        }
        logger.info("[ka10080] %s body=%s", url, body)

        rows: List[Dict[str, Any]] = []
        cont_yn, next_key = None, None

        while True:
            headers = self._headers(self.cfg.chart_api_id, "Y" if next_key else None, next_key)
            resp = requests.post(url, headers=headers, json=body, timeout=self.cfg.timeout)
            resp.raise_for_status()

            cont_yn = resp.headers.get("cont-yn", "N")
            next_key = resp.headers.get("next-key")
            js = resp.json()

            part = self._find_minute_array(js)
            if part:
                rows.extend(part)

            if len(rows) >= need or cont_yn != "Y" or not next_key:
                break

        # 중복 제거 + 정렬 + need개만 유지
        keyer = lambda r: (str(r.get("dt") or "") + str(r.get("cntr_tm") or ""))
        uniq_map: Dict[str, Dict[str, Any]] = {}
        for r in rows:
            uniq_map[keyer(r)] = r
        uniq = list(uniq_map.values())
        uniq.sort(key=keyer)  # 오래된→최신
        if need and len(uniq) > need:
            uniq = uniq[-need:]
        logger.info("[ka10080] got=%d rows (min=%s)", len(uniq), m)
        return uniq

    @staticmethod
    def _find_minute_array(payload: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        분봉 응답에서 리스트를 찾아낸다.
        문서 예시 키: 'stk_min_pole_chart_qry'
        """
        # 흔한 위치
        for k in ("stk_min_pole_chart_qry", "stk_min_chart_qry", "data", "body"):
            v = payload.get(k)
            if isinstance(v, list) and v and isinstance(v[0], dict):
                if "cntr_tm" in v[0] and ("cur_prc" in v[0] or "close" in v[0]):
                    return v
            if isinstance(v, dict):
                for vv in v.values():
                    if isinstance(vv, list) and vv and isinstance(vv[0], dict):
                        if "cntr_tm" in vv[0] and ("cur_prc" in vv[0] or "close" in vv[0]):
                            return vv
        # 전체 탐색
        for vv in payload.values():
            if isinstance(vv, list) and vv and isinstance(vv[0], dict):
                if "cntr_tm" in vv[0] and ("cur_prc" in vv[0] or "close" in vv[0]):
                    return vv
        return []

    @staticmethod
    def normalize_minute_to_ohlcv(rows: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        [{'dt':'YYYYMMDD','cntr_tm':'HHMMSS','cur_prc','trde_qty'}] → [{'ts', 'open','high','low','close','volume'}]
        OHLC가 따로 없으면 close로 보정
        """
        out: List[Dict[str, Any]] = []
        for r in rows:
            d = str(r.get("dt") or "").strip()
            t = str(r.get("cntr_tm") or "").strip()
            if not d:
                continue
            # ts
            try:
                if t:
                    ts = dt.datetime.strptime(d + t, "%Y%m%d%H%M%S")
                else:
                    ts = dt.datetime.strptime(d, "%Y%m%d")
            except Exception:
                continue

            close = r.get("close")
            if close in (None, ""):
                close = r.get("cur_prc")
            close = _to_float(close, 0.0)
            vol = _to_float(r.get("trde_qty") or r.get("volume") or 0, 0.0)

            out.append({
                "ts": ts,
                "open": close, "high": close, "low": close, "close": close,
                "volume": vol,
            })
        return out

    def minute_df(self, code: str, *, minutes: int | str = 5, need: int = 350) -> pd.DataFrame:
        rows = self.fetch_minute_rows(code, minutes=minutes, need=need)
        norm = self.normalize_minute_to_ohlcv(rows)
        df = pd.DataFrame(norm)
        if df.empty:
            return df
        for c in ("open", "high", "low", "close", "volume"):
            df[c] = pd.to_numeric(df[c], errors="coerce")
        df = df.dropna(subset=["ts", "close"]).sort_values("ts").set_index("ts")
        return df

    # ==========================================================
    # 3) ka10081: 일봉 rows → DataFrame
    # ==========================================================
    def fetch_daily_rows(
        self,
        code: str,
        *,
        base_dt: Optional[str] = None,  # 'YYYYMMDD'
        need: int = 400,
        upd_stkpc_tp: str = "1",
        exchange_prefix: str = "KRX",
    ) -> List[Dict[str, Any]]:
        url = f"{self.cfg.base_url}/api/dostk/chart"
        if not base_dt:
            base_dt = dt.datetime.now().strftime("%Y%m%d")

        body = {
            "stk_cd": _to_stk_cd(code, exchange_prefix),
            "base_dt": base_dt,
            "upd_stkpc_tp": str(upd_stkpc_tp),
        }
        logger.info("[ka10081] %s body=%s", url, body)

        rows: List[Dict[str, Any]] = []
        cont_yn, next_key = None, None

        while True:
            headers = self._headers(self.cfg.daily_api_id, "Y" if next_key else None, next_key)
            resp = requests.post(url, headers=headers, json=body, timeout=self.cfg.timeout)
            resp.raise_for_status()

            cont_yn = resp.headers.get("cont-yn", "N")
            next_key = resp.headers.get("next-key")
            js = resp.json()

            part = self._find_daily_array(js)
            if part:
                rows.extend(part)

            if len(rows) >= need or cont_yn != "Y" or not next_key:
                break

        # 중복 제거 + 정렬 + need개만 유지
        by_dt: Dict[str, Dict[str, Any]] = {}
        for r in rows:
            d = str(r.get("dt") or r.get("date") or "")
            if d:
                by_dt[d] = r
        uniq = list(by_dt.values())
        uniq.sort(key=lambda r: (r.get("dt") or r.get("date") or ""))
        if need and len(uniq) > need:
            uniq = uniq[-need:]
        logger.info("[ka10081] got=%d rows", len(uniq))
        return uniq

    @staticmethod
    def _find_daily_array(payload: Dict[str, Any]) -> List[Dict[str, Any]]:
        # 흔한 위치 탐색
        for k in ("stk_dt_pole_chart_qry", "stk_dt_chart_qry", "data", "body"):
            v = payload.get(k)
            if isinstance(v, list) and v and isinstance(v[0], dict):
                if ("dt" in v[0] or "date" in v[0]) and ("cur_prc" in v[0] or "close" in v[0]):
                    return v
            if isinstance(v, dict):
                for vv in v.values():
                    if isinstance(vv, list) and vv and isinstance(vv[0], dict):
                        if ("dt" in vv[0] or "date" in vv[0]) and ("cur_prc" in vv[0] or "close" in vv[0]):
                            return vv
        # 전체 탐색
        for vv in payload.values():
            if isinstance(vv, list) and vv and isinstance(vv[0], dict):
                if ("dt" in vv[0] or "date" in vv[0]) and ("cur_prc" in vv[0] or "close" in vv[0]):
                    return vv
        return []

    @staticmethod
    def normalize_daily_to_ohlcv(rows: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        out: List[Dict[str, Any]] = []
        for r in rows:
            ds = str(r.get("dt") or r.get("date") or "").strip()
            if not ds:
                continue
            # 날짜 파싱
            dtd = None
            for fmt in ("%Y%m%d", "%Y-%m-%d"):
                try:
                    dtd = dt.datetime.strptime(ds, fmt)
                    break
                except Exception:
                    pass
            if dtd is None:
                continue

            close = r.get("close")
            if close in (None, ""):
                close = r.get("cur_prc")
            close = _to_float(close, 0.0)
            vol = _to_float(r.get("trde_qty") or r.get("volume") or 0, 0.0)

            out.append({
                "dt": dtd,
                "open": close, "high": close, "low": close, "close": close,
                "volume": vol,
            })
        return out

    def daily_df(self, code: str, *, need: int = 400, base_dt: Optional[str] = None) -> pd.DataFrame:
        rows = self.fetch_daily_rows(code, base_dt=base_dt, need=need)
        norm = self.normalize_daily_to_ohlcv(rows)
        df = pd.DataFrame(norm)
        if df.empty:
            return df
        for c in ("open", "high", "low", "close", "volume"):
            df[c] = pd.to_numeric(df[c], errors="coerce")
        df = df.dropna(subset=["dt", "close"]).sort_values("dt").set_index("dt")
        return df

    # ==========================================================
    # 4) MACD 계산 (EMA 기반)
    # ==========================================================
    @staticmethod
    def macd_series(
        df: pd.DataFrame,
        close_col: str = "close",
        fast: int = 12,
        slow: int = 26,
        signal: int = 9,
    ) -> tuple[pd.Series, pd.Series, pd.Series]:
        """
        return: (macd, signal_line, histogram)
        """
        if df.empty or close_col not in df.columns:
            return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)

        close = pd.to_numeric(df[close_col], errors="coerce").fillna(method="ffill")

        ema_fast = close.ewm(span=fast, adjust=False, min_periods=fast).mean()
        ema_slow = close.ewm(span=slow, adjust=False, min_periods=slow).mean()
        macd = ema_fast - ema_slow
        signal_line = macd.ewm(span=signal, adjust=False, min_periods=signal).mean()
        histogram = macd - signal_line
        return macd, signal_line, histogram

    # ==========================================================
    # 5) Async 래퍼 (UI/엔진 루프에서 안전하게)
    # ==========================================================
    async def a_fetch_stock_info(self, code: str) -> Dict[str, Any]:
        return await asyncio.to_thread(self.fetch_stock_info, code)

    async def a_minute_df(self, code: str, *, minutes: int | str = 5, need: int = 350) -> pd.DataFrame:
        return await asyncio.to_thread(self.minute_df, code, minutes=minutes, need=need)

    async def a_daily_df(self, code: str, *, need: int = 400, base_dt: Optional[str] = None) -> pd.DataFrame:
        return await asyncio.to_thread(self.daily_df, code, need=need, base_dt=base_dt)

    async def a_macd_series(
        self, df: pd.DataFrame, close_col: str = "close", fast: int = 12, slow: int = 26, signal: int = 9
    ) -> tuple[pd.Series, pd.Series, pd.Series]:
        return await asyncio.to_thread(self.macd_series, df, close_col, fast, slow, signal)


# ──────────────────────────────────────────────────────────────
# 테스트
# ──────────────────────────────────────────────────────────────
if __name__ == "__main__":
    # 간단 테스트: 환경변수 ACCESS_TOKEN 필수
    logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO").upper(),
                        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    code = os.getenv("TEST_CODE", "005930")

    cfg = HTTPConfig()
    getter = DetailInformationGetter(cfg)

    print("== ka10095 / 상세 ==")
    try:
        info = getter.fetch_stock_info(code)
        print({k: info.get(k) for k in ("stock_code", "stock_name", "cur_prc", "flu_rt", "cntr_str")})
    except Exception as e:
        logger.exception("ka10095 error: %s", e)

    print("\n== ka10080 / 5분봉 350개 ==")
    try:
        df5 = getter.minute_df(code, minutes=5, need=350)
        print(df5.tail(2))
        if not df5.empty:
            macd, sig, hist = getter.macd_series(df5)
            print("last 5m MACD:", float(macd.iloc[-1]), float(sig.iloc[-1]), float(hist.iloc[-1]))
    except Exception as e:
        logger.exception("ka10080 error: %s", e)

    print("\n== ka10081 / 일봉 400개 ==")
    try:
        dfd = getter.daily_df(code, need=400)
        print(dfd.tail(2))
        if not dfd.empty:
            macd, sig, hist = getter.macd_series(dfd)
            print("last Daily MACD:", float(macd.iloc[-1]), float(sig.iloc[-1]), float(hist.iloc[-1]))
    except Exception as e:
        logger.exception("ka10081 error: %s", e)